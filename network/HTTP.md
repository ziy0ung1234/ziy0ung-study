# HTTP 웹 기본 지식

## 인터넷 통신
- '인터넷'에서 통신하는 방법
  - 인터넷 망을 통해 통신하는데 인터넷 망은 굉장히 복잡한 구조
  - 부여받은 IP주소를 통해 통신이 가능

## IP(인터넷 프로토콜)
  - 역할
    - 지정한 IP address에 데이터 전달
    - 패킷(packet)이라는 통신 단위로 데이터 전달
  - 한계
    1) 비연결성
    - 일단 보내고 봄! 패킷을 받을 대상의 서버가 존재하지 않아도 일단 그냥 보내버림
    2) 비신뢰성
    - 패킷 보냈는데 중간에 패킷이 사라질 수도 있음
    - 패킷의 용량이 클때(1500byte 이상), 끊어서 보내는데 순서대로 안올 수 있음
    3) 프로그램 구분
    - 한 PC에서 게임도 하고 음악도 듣고 다양하게 사용하는데 같은 IP를 사용 -> 이걸 어떻게 구분지을지 불명확

IP 만으로는 언급된 문제들을 해결할 수 없어서 필요한 것이 **TCP,UDP**
<br>
## TCP(Transmission Control Protocol 전송제어 프로토콜)
  - 인터넷 프로토콜 스택의 4계층
    ![인터넷 프로토콜 스택의 4계층](https://www.notion.so/HTTP-b7789253fd204801aa0ed1fc35dd2505#8da1373c99c64f8e88b1b41c23b23dd7)
    - 애플리케이션(최상위) -> 전송 계층 -> 인터넷 계층 -> 네트워크 인터페이스(ex.LAN) 계층(최하위)
    - IP를 위로 살짝 올려 TCP와 함께 보완
  - 프로토콜 계층
    ![프로토콜 계층](https://www.notion.so/HTTP-b7789253fd204801aa0ed1fc35dd2505#878950f1b64d47fb95981a1d43cae203)
    - 특징
      - 연결지향적 : 연결이 되었는가를 먼저 확인 후 메세지를 보
	⭐️TCP 3way handshake⭐️
	  - 3번의 과정을 거쳐 신뢰성 있음 -> 그다음 데이터를 전송
	  - _💡물리적으로 진짜 연결된 것은 아님!! 아~연결이 됬나 보다만 확인💡_
	  ![3way handshake](https://www.notion.so/HTTP-b7789253fd204801aa0ed1fc35dd2505#4d3a1cc0cd4c45a9b9f8b993ef69e479)
      - 데이터 전달 보증 : 메세지가 누락되었을 때 확인이 가능
        - 데이터를 보내면 잘 받았을 때 '잘 받았다'는 메세지를 보내줌
      - 순서 보장
	- 패킷1,패킷2,패킷3 순서로 보냈는데 패킷1,3,2 순서로 도착할 경우 서버가 클라이언트에게 패킷2부터 다시보내라는 메세지 전송
	_💖이것이 가능한 이유💖_
	  - 패킷 안에는 TCP 세그먼트가 포함되어 있는데 그 내용 안에는 전송제어, 순서, 검증 정보등이 포함되어있기 때문에 가능하다
      - 신뢰 할 수 있는 프로토콜
      - 현재 대부분 TCP사용

## UDP(User Datagram Protocol 사용자 데이터그램 프로토콜)

UDP는 TCP와 같은 계층에 있는 프로토콜이지만 기능이 거의 없다.
- TCP 3 way handsake X
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서 보장 X but 단순하고 빠름
-IP와 거의 같지만 `PORT`가 추가된 정도
- ***💡PORT*** - 하나의 IP로 여러가지 용도로 사용하고 있을 때 지금 사용하는 것이 어떤 애플리케이션의 패킷인지 구분할 때 쓰는것

더 최적화를 하고싶고 가능할 때 TCP는 손을 댈 수 없다. 그럴 경우에 UDP는 하얀 도화지 이기때문에 여기서 추가 작업을 진행한다. 최근 각광받고 있음

## Stateless(무상태 프로토콜)

- 서버가 클라이언트의 상태를 보존하지 않음

- stateful, stateless차이
  - stateful(상태 유지)한 상황에서는 서버가 바뀌면 원하는 데이터가 사라지기 때문에 장애가 남
  - 중간에 서버기 바뀔 때 상태 정보를 다른 서버에 미리 알려주어야 한다
  - stateless한 상황에서는 응답 서버를 쉽게 바꿀 수 있고, 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입 가능
  - stateless한 상황에서는 응답 서버를 쉽게 바꿀 수 있고, 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입 가능

- 상태 유지(브라우저 쿠키와 서버 세션등을 사용)는 최소한만 사용해야함

## Connectionless(비연결성)

- 연결을 유지하는 모델/ 연결을 유지하지 않는 모델
  - 연결을 계속해서 유지하면 클라이언트가 놀고 있어도 연결할 서버가 유지되어야하기 때문에 서버 자원이 계속해서 소모된다
  - 클라이언트 1과 TCP/IP로 연결 → 끊고 클라이언트 2와 연결 → 종료하고 클라이언트 3과 연결... ⇒ 자원을 연결 할때만 딱 주고받아서 최소한의 자원만이 유지
- 연결을 유지하지 않는 HTTP
  - 초 단위 이하의 빠른 속도로 응답
  - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서는 동시 처리하는 요청은 수십개 이하로 매우 적음
  (웹 브라우저에서 계속 연결해서 검색 버튼을 누르지 않음)
  - 서버 자원을 매우 효율적으로 사용 가능
- 한
  - 예를들어 중간에 새로 다음페이지로 넘어가면 TCP/IP 연결을 새로 맺어야함 ⇒ 즉, 3 way handshake 시간이 추가
  - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 JS, CSS, 추가 이미지등 수많은 자원들이 함께 다운로드

    🧐  그래서 지금은 HTTP Persistent Connections(지속연결)로 문제를 해결 🧐
  ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ee8507a-284f-44cc-bd97-388d055a8b7d/_2021-05-31__2.56.40.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ee8507a-284f-44cc-bd97-388d055a8b7d/_2021-05-31__2.56.40.png)
  ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00ba173f-9879-419b-8871-6b8fa5c705b2/_2021-05-31__2.56.59.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/00ba173f-9879-419b-8871-6b8fa5c705b2/_2021-05-31__2.56.59.png)
  😎 요청하고 응답하고 요청하고 응답하고를 반복하고 모든 요청과 응답이 다 끝날 때까지 연결을 지속

